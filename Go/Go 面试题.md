### 1. 在go语言中，new和make的区别？

- new 分配基本类型和聚合类型的内存地址，通过 new 结合赋值运算，将该内存地址赋给一个指向相应类型（指基本类型和聚合类型）的指针变量。
- make 分配引用类型（切片，通道等）的内存地址，该地址存储的是指向底层类型的指针。通过 make 结合赋值运算，将引用类型的内存地址赋给指向相应类型的指针变量。


### 2. 在go语言中，Printf()、Sprintf()、Fprintf()函数的区别用法是什么？

- Printf() 打印指定格式的输入到标准输出设备；Sprintf() 将指定格式的输入转成字符串；
- Fprintf() 没用过，不清楚。 -> 将指定格式化的输入输出到指定文件设备中。


### 3. 说说go语言中，数组与切片的区别？

- 声明：声明数组时，数组长度就是固定的，不可调整。切片长度在运行时可动态调整。
- 数组在内存中的分配是连续的地址空间。切片在内存中是固定大小的结构体，其中包含一个指向底层数组的指针，实际存储数据是该底层数组。
- 数组是聚合类型，由基本类型聚合而成。切片是引用类型，数组可使用 new 创建，不可使用 make 创建。切片可使用 make 创建，不可使用 new 创建。
- 由于数组是不可调整的，相比于数组，切片提供更多的方法。如 append，动态扩展底层数组。注意，底层数组在申请开辟新空间时，需要在内存中申请新底层数组空间，将旧底层数组复制到新底层数组等操作。对于使用者切片只是容量变化，但底层数组已经变化了。

- **注意：这里我们的思考维度是在数组和切片的声明，底层类型上。我们也可以发散开，看数组和切片在函数/方法等有何区别，目的是做到思维的扩展。**


### 4. 说说go语言中的协程？

- Go 中通过在函数或方法前加 go 关键字创建协程，协程是最小的可执行单元。
- go 中的协程是比操作系统线程更小的单元，Go 创建协程时，会为协程分配 2K 的栈空间。与操作系统栈空间不同的是，协程的栈空间是动态扩展的。
- Go 通过 GPM 模型调度协程到操作系统线程，真实执行的单元还是操作系统线程。假设，操作系统线程只有一个，那么多协程总是被 Go 调度器调度到同一个线程上，它的执行效果类似于并发而不是并行。如果多个协程调度到多个操作系统线程执行，那这是并行（并发）执行。
- 每个协程作为独立的可执行单元，如果是独立的执行任务，非常适合用协程来处理。当然，如果协程之间有“依赖”的话，一般通过通道来实现协程间的通信。
- 多个协程在读写共享变量时容易出现竞态，此时一般会有两种处理方式：1. 将写操作改为读操作，读操作是独立的可执行单元，对于每个协程都是并发安全的。2. 加锁，拆分共享变量为读和写部分，在写变量加互斥锁，读变量加读锁，以在并发安全和执行效率上寻求平衡。


### 5. 说说go语言中的for循环？

- for 循环一般有两种，一种是 for 中加循环条件的循环，另一种是 for 和关键字 range 结合的循环方式。
- for 和 range 结合的循环会迭代变量，以获取变量中的元素。如数组，切片，map 等。针对不同底层类型，for:range 返回的结果不同的。
- for 中有自己的块作用域，返回的迭代变量一般在块作用域中使用。

- *for循环支持continue和break来控制循环，但是它提供了一个更高级的break，可以选择中断哪一个循环 for循环不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量*  
- **注：这是语言层面还要在想的一步，即 for 还有什么使用场景**


### 6. 说说go语言中的switch语句？

- switch 是判断条件分支的语句。switch 结合 case 可判断条件分支，switch 也可结合 case 和接口判断接口的类型。
- switch 中的条件分支通常会结合 default 关键字使用，以表明如果没有匹配条件分支，则走到 default 分支处理。
- Go 提供一个 fallthrough 关键字用来跳过分支判断。

- *只有在case中明确添加fallthrough关键字，才会继续执行紧跟的下一个case*


### 7. go语言中没有隐藏的this指针，这句话是什么意思？

- 在一些面向对象语言如 Java 中，this 指的是实例化的对象，通过 this 可以实现构造函数，继承等。Go 中没有构造函数，继承等。实例化的对象，在调用其方法时通过接收者（值接收者，指针接收者）获取对象的信息，因而不需要 this。

- ChatGPT: 在Go语言中，确实没有像一些面向对象编程语言（如C++、Java）中的隐式 this 指针。这是因为Go语言并不是传统意义上的面向对象语言，它没有类的概念，也没有继承。因此，Go中没有类似 this 指针的东西。在Go中，如果你需要在方法中引用当前的对象或结构体实例，通常会将该实例显式地作为方法的接收者传递。接收者可以是值类型或指针类型。


### 8. go语言中的引用类型包含哪些？

- 切片，map 和通道。

- 切片，map 和通道。在 <<Go 程序设计语言>> 一书中将接口作为单独的接口类型加以讨论...
**注：接口算引用类型吗？接口可以看作是接口类型，起底层实现是结构体对象，我们可以把接口的讨论加上去**


### 9. go语言中指针运算有哪些？


- 结合实际需求来。需要操作同一个底层数据的时候需要用指针运算。

- ChatGPT: Go语言中并不支持传统的指针运算（如指针加减、指针间的减法等），这是为了简化语言设计并增强安全性。Go的指针操作主要包括取地址、解引用、指针比较和指针传递等基本操作。通过限制指针运算，Go避免了许多与内存管理相关的复杂问题，使得程序更加健壮。
**注：这个题目可能让人看不懂，有歧义。目前看 ChatGPT 的答案更有道理**

### 10. 说说go语言的main函数

- go 语言的 main 函数是 go 程序的入口函数，程序执行的第一个函数。
- go 的 main 会被作为主 goroutine 函数执行。
- main 函数是无参数，无返回值的函数。

- *补充：main 函数必须定义在 main 包*


### 11. 说说go语言的同步锁？

- 同步锁用来防止协程的竞态，通过对竞态资源加锁的方式实现协程的并发安全。
- 同步锁分读锁和互斥锁。拿到读锁的协程可以读取资源，不可以写。拿到互斥锁的协程可以进行读写资源操作，未拿到互斥锁的协程则进入阻塞状态直到获取读写锁。
- 同步锁的背后实现？


### 12. 说说go语言的channel特性？

- channel 是引用类型，通过 make 关键字创建，函数或者方法中传递 channel，实际传递的是引用。
- channel 分为无缓冲和有缓冲 channel。在读写数据时，无缓冲 channel 需要有xxx，有缓冲通道的容量...
- 用途：channel 常被用来作为协程之间通信的桥梁。
- 使用 1：channel 结合 for 循环可实现读取 channel 中的内容，如果 channel 无内容则阻塞。channel 可关闭，对于 for 循环来说，如果 channel 关闭则跳出 for 循环。
- 使用 2：试图往关闭的 channel 写或读数据将造成 panic，go 可以判断 channel 是否是关闭的。
- 关闭 3：channel 可实现广播的效果。

**注意：这里我们回答的不是特性，是怎么用。下面这个回答是非常不错的**

```
A. 给一个 nil channel 发送数据，造成永远阻塞

B. 从一个 nil channel 接收数据，造成永远阻塞

C. 给一个已经关闭的 channel 发送数据，引起 panic

D. 从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值

E. 无缓冲的channel是同步的，而有缓冲的channel是非同步的
```


### 13. go语言触发异常的场景有哪些？

- 试图解引用 nil 指针。
- 类型转换的时候，类型不一致将触发异常。
- 不可计算的数值将引起异常，如 1/0 等。

**这个问题如果我们找场景会找出好多个零碎的场景，不成系统，成系统的应该是从大框架细分的，要看到我们的思考过程的回答。**

重新回答：

- 基本类型：类型转换时会触发异常，如将 float 赋值给 int。变量运算会触发异常，会 1/0。
- 引用类型：对 nil 解引用会触发异常。向一个 nil 通道写数据会引起异常。
- 接口类型：接口类型的比较会引起异常，如接口中包括不可比较类型，试图比较两个接口将会触发异常。

引起异常的场景有不少，在实际的开发过程中要结合具体问题具体分析。


### 14. 说说go语言的select机制？

- select 结合 case 用于匹配多个通道中的一个，通过 select 可以实现读取通道的多路复用。

**这个回答不太好，没有往上提，局限在了语言层面。我们可以结合具体实例在抽象，把这个问题拔高一层。下面这个答案就很不错**

```
A. select机制用来处理异步IO问题

B. select机制最大的一条限制就是每个case语句里必须是一个IO操作

C. golang在语言级别支持select关键字
```

### 15. 说说进程、线程、协程之间的区别？

- 进程是程序运行的单元，进程有进程空间。线程是进程内部的执行单元，线程有自己的线程空间，包括在进程空间内。一个进程可以有多个线程。协程是 Go 语言层面的执行单元，协程要比线程的粒度细，Go 调度器调度协程到线程上，协程和线程的对应关系是 m:n。
- 线程的空间是固定的，而协程的空间是动态扩展的。
- 进程间的通信一般通过 IPC/https 等实现进程通信，协程一般通过通道通信。
- 进程资源竞争一般通过共享资源，比如文件加锁的形式防止进程资源抢占。线程资源竞争和协程一般通过互斥锁等防止资源抢占。


ChatGPT 给出的这个问题的回答真好啊：

进程、线程和协程是计算机程序执行的三种不同的单元，它们在资源管理、调度方式和执行上下文方面存在显著差异。以下是对它们之间区别的详细解释：

### 1. **进程（Process）**

#### **定义**
- 进程是操作系统中资源分配的基本单位，每个进程都有自己独立的内存空间、文件描述符、全局变量等资源。一个进程可以包含多个线程。

#### **特点**
- **独立性**：进程是相互独立的，进程之间的通信（如通过管道、消息队列、共享内存等）通常比线程间通信复杂。
- **资源开销大**：创建或切换进程的开销较大，因为操作系统需要为每个进程分配独立的资源（如内存空间）。
- **安全性高**：由于进程拥有独立的内存空间，一个进程崩溃不会影响其他进程，这提高了系统的稳定性。

#### **使用场景**
- 适合需要高度隔离的任务，比如不同的用户程序、后台服务等。
- 需要在不同的CPU上并行运行，进程可以充分利用多核处理器。

### 2. **线程（Thread）**

#### **定义**
- 线程是CPU调度的基本单位，属于进程内的执行单元。线程之间共享进程的资源（如内存、文件描述符），但有独立的栈、程序计数器和寄存器。

#### **特点**
- **轻量级**：线程比进程轻量，创建和销毁线程的开销比进程低。线程之间的上下文切换也比进程之间的切换快。
- **共享内存**：同一进程内的线程共享相同的内存空间，这使得线程之间的数据共享更简单，但也引入了数据竞争和同步问题。
- **并发性**：线程在多核处理器上可以实现并发执行，从而提高程序的执行效率。

#### **使用场景**
- 适合需要共享数据的并发任务，如并行计算、服务器处理多个请求等。
- 用于需要高效利用多核处理器的场景，通过多线程实现并发。

### 3. **协程（Coroutine）**

#### **定义**
- 协程是一种更轻量级的执行单元，相较于线程，协程由程序自身调度而非操作系统。协程通常在用户态实现，而非内核态。

#### **特点**
- **极轻量**：协程的创建、销毁和切换的开销非常低，通常只是简单的函数调用和栈操作。一个进程或线程内可以创建大量的协程。
- **非抢占式调度**：协程的执行是合作式的，即协程只有在主动让出控制权（通过`yield`或`await`等机制）后，其他协程才能运行。因此，协程不需要像线程那样处理复杂的同步问题。
- **异步编程**：协程非常适合处理异步I/O操作，例如网络请求或文件读写，可以在等待I/O完成时让出执行权，从而在同一个线程内实现高效的并发。

#### **使用场景**
- 适合I/O密集型的任务，如网络服务器、异步编程等。
- 适用于需要大量并发但不需要高并行的场景，如协程可以高效地管理数万个并发连接。

### **对比总结**

1. **资源开销**：
   - **进程**：资源开销大，每个进程有独立的内存空间和资源。
   - **线程**：资源开销较小，线程共享进程的资源，但有独立的执行栈。
   - **协程**：资源开销最小，协程在用户态运行，调度开销低。

2. **隔离性**：
   - **进程**：最强的隔离性，进程间不会直接共享内存。
   - **线程**：隔离性较弱，线程间共享进程的资源，存在数据竞争风险。
   - **协程**：隔离性可控，协程间可以通过局部变量共享数据，但一般不会直接共享全局资源。

3. **调度方式**：
   - **进程**：由操作系统内核调度，调度开销大。
   - **线程**：由操作系统内核调度，调度开销相对较小。
   - **协程**：由用户态程序调度，调度开销极小。

4. **并发与并行**：
   - **进程**和**线程**：都可以实现真正的并行（特别是在多核CPU上）。
   - **协程**：主要用于并发，通常在单线程内实现。

5. **使用复杂性**：
   - **进程**：由于资源隔离，进程间通信（IPC）较复杂。
   - **线程**：需要处理同步和数据竞争问题。
   - **协程**：编程相对简单，尤其适合异步操作，但需要谨慎设计协程的调度逻辑。

### **总结**
- **进程**适合需要独立运行且资源隔离性高的任务。
- **线程**适合需要高效并发且可以共享数据的场景。
- **协程**则非常适合I/O密集型和高并发的场景，尤其是在需要大量并发而不需要真正并行的情况下。


### 16. 写出下面代码输出内容。
```
package main
import("fmt") 
func main() {
    defer_call()
}
func defer_call() {
    defer func() {
        fmt.Println("打印前")
    }()
    defer func() {
        fmt.Println("打印中")
    }() 
    defer func() {
        fmt.Println("打印后")
    }() 
    panic("触发异常")
}
```

输出：
```
"触发异常"
"打印后"
"打印中"
"打印前"
```

考点：
- defer 调用顺序
- defer 结合 panic 的行为

这里我们的回答是错误的，原因在于对于 panic 的行为不清楚，panic 是最后触发的函数。结果是：
```
"打印后"
"打印中"
"打印前"
"触发异常"
```

如果我们将 panic 改为 `fmt.Println` 则打印结果是：
```
"触发异常"
"打印后"
"打印中"
"打印前"
```

### 17. 以下代码有什么问题，说明原因。

```
type student struct {
    Name string Age int
}
func pase_student() {
    m := make(map[string] * student)
    stus := [] student {
        {
            Name: "zhou",
            Age: 24
        }, {
            Name: "li",
            Age: 23
        }, {
            Name: "wang",
            Age: 22
        },
    }
    for _, stu := range stus {
        m[stu.Name] = &stu
    }
}
```

ChatGPT:
在这个for循环中，stu是循环变量。Go语言中，循环变量stu在每次迭代时被重用，也就是说，所有的stu实际上是同一个变量，只是这个变量的值在每次迭代时被更新。当你使用&stu获取地址时，每次循环得到的都是同一个变量的地址。因此，最终m[stu.Name]中保存的都是最后一次迭代的stu的地址。


这个问题可能会以各种变体出现，要注意。

### 18. 下面的代码会输出什么？并说明原因。

```
func main() {
    runtime.GOMAXPROCS(1)
    wg := sync.WaitGroup {}
    wg.Add(20)
    for i := 0; i < 10; i++ {
        go func() {
            fmt.Println("A: ", i) 
            wg.Done()
        }()
    }
    for i := 0; i < 10; i++ {
        go func(i int) {
            fmt.Println("B: ", i)
            wg.Done()
        }(i)
    }
    wg.Wait()
}
```

输出顺序是不固定的，但是 B 是从 0 到 9 顺序输出的。而 A 则有待讨论，A 是直接使用外部变量，协程打印的都是外部变量的 i 的值。这里如果 for 执行完，i 更新为 10 之后协程执行，那么打印都为 10。如果在协程外循环内延迟打印（协程每次都用最新的 i），则答应是按顺序的。比如：
```
for i := 0; i < 10; i++ {
    time.Sleep(1 * time.Second)
    go func() {
        fmt.Println("A: ", i) 
        wg.Done()
    }()
}
```

将按顺序输出 A。


### 19. 下面的代码将输出什么？

```
type People struct {}
func(p * People) ShowA() {
    fmt.Println("showA")
    p.ShowB()
}
func(p * People) ShowB() {
    fmt.Println("showB")
}
type Teacher struct {
    People
}
func(t * Teacher) ShowB() {
    fmt.Println("teacher showB")
}
func main() {
    t := Teacher {}
    t.ShowA()
}
```

这里考察的是 Go 中的组合，输出的是 showAshowB。


### 20. 下面代码会触发异常吗？为什么？

```
func main() {
    runtime.GOMAXPROCS(1) 
    int_chan := make(chan int, 1) 
    string_chan := make(chan string, 1) 
    int_chan <- 1 
    string_chan <- "hello"
    select {
        case value := <-int_chan:
            fmt.Println(value)
        case value := <-string_chan:
            panic(value)
    }
}
```

这段代码很有意思的点在于通道是有缓冲通道，如果是无缓冲通道，那么肯定死锁，阻塞在第一个协程上。

这里是有缓冲通道，代码是能走到 select 的，那么问题就变成  select 是怎么选择这两个通道的。select 是根据先后顺序，如果是同时的话则会随机选取一个通道接收，执行相应的语句。这里虽然 int_chan 通道在前，但并不能表示它接收的时间也在前，这里只能说大部分时候输出 1，有可能触发异常 panic。


### 21. 下面代码输出什么？

```
func calc(index string, a, b int) int {
    ret := a + b 
    fmt.Println(index, a, b, ret) 
    return ret
}
func main() {
    a := 1
    b := 2 
    defer calc("1", a, calc("10", a, b))
    a = 0 
    defer calc("2", a, calc("20", a, b)) 
    b = 1
}
```

defer 是特别容易考的点。这里输出什么，我们要明确 defer 函数入栈，延迟调用，但是 defer 的参数不是，参数是立即执行的，所以这里的 `calc("10", a, b)` 是首先执行的。

还有这里是按值传递，如果按指针传递，在看看会输出什么？
```
func calc(index string, a *int, b int) int {
	ret := *a + b
	fmt.Println(index, *a, b, ret)
	return ret
}

func main() {
	a := 1
	b := 2
	defer calc("1", &a, calc("10", &a, b))
	a = 0
	defer calc("2", &a, calc("20", &a, b))
	b = 1
}
```

### 22. 请写出一下内容的输出？
```
func main() {
    s := make([] int, 5)
    s = append(s, 1, 2, 3)
    fmt.Println(s)
}
```

这里的考点在于 make 的初始化会填充零值。其实 new 也是的，只不过 new 不能调用 append。

### 23. 下面的代码有什么问题？

```
type UserAges struct {
    ages map[string]
    int sync.Mutex
}
func(ua * UserAges) Add(name string, age int) {
    ua.Lock()
    defer ua.Unlock()
    ua.ages[name] = age
}
func(ua * UserAges) Get(name string) int {
    if age, ok := ua.ages[name]; ok {
        return age
    }
    return -1
}
```

这个代码真没啥问题，我们在实际执行的时候也没发现啥问题。如果说有什么那就是在读 ages 的时候要加锁，但是读本身是并发安全的。


### 24. 下面的迭代会有什么问题？

```
func(set * threadSafeSet) Iter() <-chan interface {} {
    ch := make(chan interface {})
    go func() {
        set.RLock()
        for elem := range set.s {
            ch <-elem
        }
        close(ch) 
        set.RUnlock()
    }()
    return ch
}
```

这段代码非常有意思，是我们可以多咀嚼几遍的。首先，在调用时 ch <-elem 写数据到通道，方法 Iter 将通道中的数据读出来，不会造成死锁。

那么，这里的问题在于 Iter 只会返回一次，而协程是遍历 set.s 往 ch 中写数据，只会返回第一个遍历的元素，并且返回之后，主协程退出，这个协程会阻塞在写通道，不过它是子协程，程序还是会正常退出的。

举个例子，更改示例看输出：
```
type threadSafeSet struct {
	sync.RWMutex
	s []interface{}
}

func (set *threadSafeSet) Iter() <-chan interface{} {
	ch := make(chan interface{})
	go func() {
		set.RLock()
		for elem, value := range set.s {
			ch <- value
			println("Iter:", elem, value)
		}
		close(ch)
		set.RUnlock()
	}()
	return ch
}

func main() {
	th := threadSafeSet{
		s: []interface{}{
			"1", "2",
		},
	}
	v := <-th.Iter()
	fmt.Println(v)
}
```

输出：
```
Iter: 0 (0x482d00,0x4b3868)
1
```

如果将无缓冲通道改成有缓冲通道，如下：
```
func (set *threadSafeSet) Iter() <-chan interface{} {
	ch := make(chan interface{}, 2)
	go func() {
		set.RLock()
		for elem, value := range set.s {
			ch <- value
			fmt.Println("Iter:", elem, value)
		}
		close(ch)
		set.RUnlock()
	}()
	return ch
}

func main() {
	th := threadSafeSet{
		s: []interface{}{
			"1", "2", "3", "4",
		},
	}
	v := <-th.Iter()
	fmt.Println(v)
}
```

试问会输出什么？


### 25. 一下代码能编译过去吗？

```
package main
import (
    "fmt"
)
type People interface {
    Speak(string) string
}
type Stduent struct {}
func(stu * Stduent) Speak(think string)(talk string) {
    if think == "bitch" {
        talk = "You are a good boy"
    } else {
        talk = "hi"
    }
    return
}
func main() {
    var peo People = Stduent {}
    think := "bitch"
    fmt.Println(peo.Speak(think))
}
```

不能，因为当指针接收者实现方法的时候，如果通过接口调用该方法，编译器内部会获取变量的地址，然后拷贝副本，副本中存储的是变量的地址，接着在调用变量的方法。传递结构体，编译器在拷贝副本的时候，副本中存储的是变量，而不是地址，这意味调用对象的方法，实际上调用的是对象副本的方法，对于指针接收者的方法来说这是不允许的。第二个原因是，编译器无法隐式获取变量的地址。

### 26. 以下代码打印出来什么内容，为什么？

```
package main
import(
    "fmt"
) 
type People interface {
    Show()
}
type Student struct {}
func(stu * Student) Show() {}
func live() People {
    var stu * Student
    return stu
}
func main() {
    if live() == nil {
        fmt.Println("AAAAAAA")
    } else {
        fmt.Println("BBBBBBB")
    }
}
```

BBBBBBB，因为接口是有两部分组成，类型和数据，这里将 nil 对象传给接口，接口的类型是对象的类型，数据是 nil，这样的接口不等于 nil。


### 参考

- [golang 语言面试题总结](https://www.jishuchi.com/read/go-interview/3435)

