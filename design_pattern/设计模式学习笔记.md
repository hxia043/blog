# 0. 前言

为什么要学习设计模式？

软件不像硬件/建筑在时效性上是不一样的，软件的时效性更短，随着时间会变得臃肿，复杂，难以维护。

要写出更能适应时效性的软件，就要有一定的方式方法。这里的适应是满足软件可复用，可扩展，可维护，灵活性，简洁性，可测试性的要求。

这里要注意的是，时效性。时效性不是速度，试想，如果企业对时效性的要求不高，对速度的要求高。那么设计高质量的代码的需求就会降低，反而对如何实现功能的需求会更强。

作为一个有品味的程序员，我们要看重的是时效性，要写高质量的代码。

软件要满足可复用，可扩展，可维护，灵活性，简洁性，可测试性的要求，这些要求具体指的是什么。

- 可复用：可复用是我们的软件是没有冗余的，对于重复逻辑是可以拿来即用的。比如，业务逻辑和控制逻辑，我们的控制逻辑更通用，更容易被复用，这部分就可以满足可复用的要求。
- 可扩展：可扩展是基于软件是不稳定，易变的。为了以后可以更好的扩展，而不做大手术，可以在设计软件时考虑可扩展性。可扩展性是面向未来的，满足可扩展性会引入复杂度，这是一种平衡，要具体场景具体分析。
- 可维护：可维护是一个比较 general 的要求，可维护需要可复用，可扩展，可测试等等才能满足可维护的要求。


我们需要有内功心法和招数才能满足这些要求。

内功心法是设计模式的原则，介绍这些原则如下：

SOLID 原则：
- S（Single Responsibility Principle, SRP）: 单一职责原则。类，函数，接口的职责要单一。单一才能“专人专事”，才能高内聚。
- O（Open Closed Principle, OCP）: 开闭原则，对扩展开放，对修改关闭。这种好处在于模块化，满足单一职责原则，坏处在于复杂度上去了，满足开闭原则也是一种平衡。
- L（Liskov Substitution Principle, LSP）: 里氏替换原则，子类和父类的逻辑要一致，按照协议而不是按照行为。类似的，如果函数名是协议的话，那么函数内容就是子类/实现，子类实现要按照函数名协议，而不是行为。
- I（Interface Segregation Principle, ISP）: 接口隔离原则，理解接口隔离原则不应从接口层面出发，而要把接口理解成 API/组 API/函数/接口。接口隔离原则是站在客户端层面说的，如果客户端不需要该接口的行为，不要暴露给客户端，要隔离。以函数为例，如果库中的函数不用被客户端调用，我们要隐藏封装该函数不让客户端调用。
- D（Dependency Inversion Principle, DIP）: 依赖反转原则，这个原则是很重要的原则。依赖这里的依赖是谁依赖谁，是高层模块依赖于低层模块，是业务模块依赖控制模块，是客户端依赖于服务端。这里为什么这么依赖是由于“模块”的特性，控制模块是相对稳定，不变的，可复用的。低层模块是专用的，稳定的。服务端面向接口开发，也是稳定的。所以依赖是变化的依赖不变的。这也满足了可复用的要求。

除了 SOLID 原则，还有 KISS，YAGNI，DRY 和 LoD 原则，介绍如下：
- KISS：Keep It Simple and Stupid。这个简单可以从多个层面解释，设计简单，代码易懂，满足可读性和可维护性的要求。并且，注意这里的简单是站在谁的角度看的简单，比如复杂的库函数，如果从调用者来说保持接口简单是核心，从库函数开发来说，库函数实现简单易懂就是核心要求。
- YAGNI：Don't Repeat Yourself。这里的重复要从几个层面去看，代码逻辑重复，功能重复，执行重复，接口重复等等都是重复，不要重复是满足可复用，可维护等要求。
- LoD: Law of Demeter，迪米特法则。又叫最少知识原则。这个原则是每个模块只应了解与它关系密切的模块的有限知识，或者说，每个模块只和自己的“朋友”说话，不和“陌生人”说话。迪米特法则是满足低耦合的很重要的法则，这里从两个方面减少耦合，只了解关系密切的模块，只了解有限的知识。

这几个原则是软件开发的内功心法，在设计软件时，要围绕着这几个原则构建，满足了这几个原则，基本上软件也满足了可复用，可维护，可扩展等的要求。


**有一点要注意的是，这些原则并不是为面向对象量身打造的。其它语言也能实现，只不过面向对象自带的封装，继承，多态等特性能很好的支持这些原则，但并不是只有面向对象能做到。**

# 1. 设计模式

常用的设计模式是我们要学习至熟练的。

![设计模式](./images/design%20pattern.jpg)

## 1.1 创建型设计模式

**单例模式**

单例模式是创建项目唯一对象的模式，又分为懒汉和饿汉创建。懒汉创建只在需要的时候创建单例，而饿汉是在项目初始化阶段即创建单例。

懒汉单例在需要的时候创建，更加灵活。但是，如果创建单例时间较长，依赖过多，则容易导致在需要时操作等待时间过长的问题。而这部分等待时间放在初始化阶段则能很好避免单个操作执行时间过长的问题。  
饿汉单例与此相反，初始化阶段即创建单例，对操作来说更加友好，但是如果单例在使用时用不到，又会导致冗余对象的问题。

工程中要结合具体需求分析。

单例在应对多线程时，需要加两把锁。第一把锁是防止多线程访问临界资源创建多单例。第二把锁是避免多线程等待访问锁而设，第二把锁能有效分流大多数线程。

项目中单例的实际应用有 `LCM engine Proxy` 实例。

**工厂方法**

简单工厂我们用的比较多，比如 `swic` 根据传入类型选择创建哪种形式的数据库实例。

**建造者模式**

这个 `swic` 也有，根据不同的外部参数创建 `image manager`。


在 Kubernetes 源码中，informer factory 结合 工厂模式和建造者模式创建不同的实例。如下：
```
// https://github.com/kubernetes/kubectl/blob/master/pkg/cmd/get/get.go

r := f.NewBuilder().
    Unstructured().
    NamespaceParam(o.Namespace).DefaultNamespace().AllNamespaces(o.AllNamespaces).
    FilenameParam(o.ExplicitNamespace, &o.FilenameOptions).
    LabelSelectorParam(o.LabelSelector).
    FieldSelectorParam(o.FieldSelector).
    Subresource(o.Subresource).
    RequestChunksOf(chunkSize).
    ResourceTypeOrNameArgs(true, args...).
    ContinueOnError().
    Latest().
    Flatten().
    TransformRequests(o.transformRequests).
    Do()
```

# 1.1 结构型设计模式

我们在每个结构型设计模式篇中单独列出了常用的设计模式，在这里做一个总结。

装饰，代理，桥接，适配器每种设计模式各有不同。

装饰模式是为了增强类的功能，代理模式是使用同样的接口，为的是添加非业务功能，适配器是适配接口，桥接是为了解耦抽象和实现。

代理模式：代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。  
桥接模式：桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。  
装饰器模式：装饰器模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。  
适配器模式：适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。  

