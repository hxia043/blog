# 0. 前言

为什么要学习设计模式？

软件不像硬件/建筑在时效性上是不一样的，软件的时效性更短，随着时间会变得臃肿，复杂，难以维护。

要写出更能适应时效性的软件，就要有一定的方式方法。这里的适应是满足软件可复用，可扩展，可维护，灵活性，简洁性，可测试性的要求。

这里要注意的是，时效性。时效性不是速度，试想，如果企业对时效性的要求不高，对速度的要求高。那么设计高质量的代码的需求就会降低，反而对如何实现功能的需求会更强。

作为一个有品味的程序员，我们要看重的是时效性，要写高质量的代码。

继续，我们的软件要满足可复用，可扩展，可维护，灵活性，简洁性，可测试性的要求。那么，详细展开几个要求看看具体指的是什么。

- 可复用：可复用是我们的软件是没有冗余的，对于重复逻辑是可以拿来即用的。比如，业务逻辑和控制逻辑，我们的控制逻辑更通用，更容易被复用，这部分就可以满足可复用的要求。
- 可扩展：可扩展是基于软件是不稳定，易变的。为了以后可以更好的扩展，而不做大手术，可以在设计软件时考虑可扩展性。可扩展性是面向未来的，满足可扩展性会引入复杂度，这是一种平衡，要具体场景具体分析。
- 可维护：可维护是一个比较 general 的要求，可维护需要可复用，可扩展，可测试等等才能满足可维护的要求。


我们需要有内功心法和招数才能满足这些要求。

内功心法是设计模式的原则，我们的招数设计模式都是围绕着这些原则展开的。我们介绍这些原则如下：

SOLID 原则：
- S（Single Responsibility Principle, SRP）: 单一职责原则。类，函数，接口的职责要单一。单一才能“专人专事”，才能高内聚。
- O（Open Closed Principle, OCP）: 开闭原则，对扩展开放，对修改关闭。这种好处在于模块化，满足单一职责原则，坏处在于复杂度上去了，满足开闭原则也是一种平衡。
- L（Liskov Substitution Principle, LSP）: 里氏替换原则，子类和父类的逻辑要一致，按照协议而不是按照行为。类似的，如果函数名是协议的话，那么函数内容就是子类/实现，子类实现要按照函数名协议，而不是行为。
- I（Interface Segregation Principle, ISP）: 接口隔离原则，理解接口隔离原则不应从接口层面出发，而要把接口理解成 API/组 API/函数/接口。接口隔离原则是站在客户端层面说的，如果客户端不需要该接口的行为，不要暴露给客户端，要隔离。以函数为例，如果库中的函数不用被客户端调用，我们要隐藏封装该函数不让客户端调用。
- D（Dependency Inversion Principle, DIP）: 依赖反转原则，这个原则是很重要的原则。依赖这里的依赖是谁依赖谁，是高层模块依赖于低层模块，是业务模块依赖控制模块，是客户端依赖于服务端。这里为什么这么依赖是由于“模块”的特性，控制模块是相对稳定，不变的，可复用的。低层模块是专用的，稳定的。服务端面向接口开发，也是稳定的。所以依赖是变化的依赖不变的。这也满足了可复用的要求。

除了 SOLID 原则，还有 KISS，YAGNI，DRY 和 LoD 原则，介绍如下：
- KISS：Keep It Simple and Stupid。这个简单可以从多个层面解释，设计简单，代码易懂，满足可读性和可维护性的要求。并且，注意这里的简单是站在谁的角度看的简单，比如复杂的库函数，如果从调用者来说保持接口简单是核心，从库函数开发来说，库函数实现简单易懂就是核心要求。
- YAGNI：Don't Repeat Yourself。这里的重复要从几个层面去看，代码逻辑重复，功能重复，执行重复，接口重复等等都是重复，不要重复是满足可复用，可维护等要求。
- LoD: Law of Demeter，迪米特法则。又叫最少知识原则。这个原则是每个模块只应了解与它关系密切的模块的有限知识，或者说，每个模块只和自己的“朋友”说话，不和“陌生人”说话。迪米特法则是满足低耦合的很重要的法则，这里从两个方面减少耦合，只了解关系密切的模块，只了解有限的知识。

这几个原则是软件开发的内功心法，在设计软件时，要围绕着这几个原则构建，满足了这几个原则，基本上软件也满足了可复用，可维护，可扩展等的要求。


有一点要注意的是，这些原则并不是为面向对象量身打造的。其它语言也能实现，只不过面向对象自带的封装，继承，多态等特性能很好的支持这些原则，但并不是只有面向对象能做到。

# 1. 设计模式及其实现



